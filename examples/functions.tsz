{
    sum := (a: number, b: number): number => a + b;
    
    asyncSum := async (a: number, b: number): Promise<number> => {
        return a + b;
    };

    mut result := sum(1, 2);
    result = await asyncSum(2, 3);
}

{
    mutator := (mut value: number): void => {
        value = value + 2;
    }

    mut myNumber := 5;
    mutator(myNumber);

    // or with bind syntax
    myNumber::mutator();

    console.log(myNumber) // will log 9
}

{
    generator := *(): Generator<number> => loop {
        yield Math.random();
    }

    asyncGenerator := async *(): AsyncGenerator<number> => loop {
        yield Math.random();
    }
}

{
    map := <Input, Output>(list: Input[], mapper: (input: Input) => Output): Output[] => {
        result: Output[] = [];
        for (item of list)  {
            result.push(mapper(item));
        }
        return result;
    }

    numbers := [1, 2, 3, 4];

    // convert numbers to strings
    mut result: string[];

    // plain
    result = map(numbers, i => String(i));

    // with pipeline
    result = numbers |> map(#, i => String(i));

    // with bind syntax
    // bind will pass the left hand side as the first parameter to the called function
    result = numbers::map(i => String(i));

    // with block syntax
    // a block will be passed as the last parameter to the left hand side function
    // if the block does not have parameters you can omit the piped arguments
    result = map(numbers) |i| {
        String(i)
    }

    // with block syntax unbraced
    result = map(numbers) |i| String(i);

    // with bind and block
    result = numbers::map |i| String(i);
}

{
    ErrorType := enum {
        Unavailable,
        NotExistant,
    }

    OpenError : ErrorType.Unavailable | ErrorType.NotExistant | {message: string};
    
    declare open: (filePath: string): Result<Resource, OpenError>;
    declare close: (resouce: Resource): void;

    resourceHandler := (filePath: string): OpenError? => {
        resource := try filePath::open();
        
        // same as above
        // resource := match (filePath::open()) {
        //     r -> Ok(r): r,
        //     e -> Error(e): return e,
        // }

        defer resource::close();

        // do some work with the resource
    }
}