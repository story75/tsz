{
    constant := 42; // type can be trivially infered
    mut value := 5; // type can be trivially infered

    typedConstant : number = 42;
    mut typedValue : number = 5;

    mut optional : number?; // variables without an initializer must specify a type
    optional = 1;
}

{
    numberList: number[] = [1, 2, 3];
    stringList: string[] = ["foo", "bar"];
    tupleMixedList := [1, "foo"]; // will be infered as [number, string];
    mut mixedList := [1, "foo"]; // will is still infered as [number, string];

    numberTuple: [number, number] = [1, 1];
    mut mutableNumberTuple: [number, number] = [1, 1];
    mut mutableNumberList = [1, 1]; // believe it or not, also [number, number]
}

{
    add := (a: number, b: number): number => a + b;

    console.log(add(1, 2)); // 3
}

// object literals
{
    options := {
        a := 1,
        b : string = 'foo', // same as just b := 'foo', because type can be trivially infered
        mut c : number?, // optional number property
        d := true,
        e := [1, 2, 3],
        f := {
            mut a := 'nested',
        },
    };
    
    console.log(options.a); // 1
    console.log(options.b); // "foo"
    console.log(options.c); // undefined
    console.log(options.d); // true
    console.log(options.e); // [1, 2, 3]
    console.log(options.f); // { a: "nested" }
}